%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Projekt:   SEN,ROB - Projekt - Automatická plachetnice                     %%
%% Autors:    Ales Horky, xhorky17, FIT@VUTBR                                 %%
%%            Michal Wiglazs, xwigla00, FIT@VUTBR                             %%
%% Datum:     20.12.2012                                                      %%
%% Verze:     1.0                                                             %%
%% Formát:    LaTeX                                                           %%
%% Kódování:  UTF-8                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%makra
\newcommand{\uv}[1]{\quotedblbase #1\textquotedblleft}

\newcommand{\conLine}[1]{ \begin{description} \item[~~~~] \texttt{#1} \end{description}}

%prebambule
\documentclass[a4paper,11pt,onecolumn]{article}
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{url}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage[total={16cm,23.5cm}, top=3cm, left=2.25cm]{geometry}

\title{Automatická plachetnice}
\author{Aleš Horký, Michal Wiglasz}
\date{}


%\frenchspacing

%telo
\begin{document}

\begin{titlepage}
\begin{center}
{\LARGE \textsc{Vysoké učení technické v~Brně\\}}
{\Large \textsc{Fakulta informačních technologií\\}}

\vspace{\stretch{0.382}}
{\LARGE Dokumentace k~projektu do SEN a ROB\\ ~ \\}
{\Huge Automatická plachetnice}
\vspace{\stretch{0.618}}
\end{center}
{\Large Aleš Horký\\Michal Wiglasz \hfill
\today\\}
\end{titlepage}

\section{Úvod}
Našim cílem v~tomto projektu je vytvořit plachetnici, která umí autonomně natáčet své plachty do vhodného úhlu vzhledem k~aktuálnímu směru větru. Plachetnice by se díky tomu měla umět ve větru pohybovat v~prakticky libovolném směru a v~důsledku automaticky řízeného kormidla dosáhnout i určeného bodu. Protože je cílem postavit ukázkový prototyp a elektřina se s~vodou nemá moc ráda, bude plachetnice jezdit na kolečkách a po suchém povrchu. Navíc tak odpadnou problémy s~nakláněním v~důsledku tlaku větru a driftu\footnote{Drift plachetnice je síla, která ji unáší ve směru větru a proudu.}.

Velký vliv na výběr tématu zadání měla plavba na plachetnici po Jadranu, kterou jsme podnikli těsně před začátkem semestru. Zde jsme přišli na to, že trimování plachet je na rekreační úrovni (dokud nepřijde 30uzlová vychřice) v~podstatě mechanická záležitost, a napadlo nás, že by ji bylo možné do jisté míry zautomatizovat. Rozhodli jsme se využít tohoto projektu, abychom tuto teorii ověřili na modelu.

Protože nemáme s~modelářstvím téměř žádné zkušenosti, rozhodli jsme se vytvořit konstrukci ze stavebnic Merkur a Lego Technics. K~ovládání plachet se nám před započetím vývoje podařilo získat tři servomotory -- jeden větší Tower Pro 9805BB a dva menší HItec HS-422. Jako řidící jednotku robota jsme se rozhodli využít programovatelné zařízení FITkit, se kterým jediným máme letmé zkušenosti z~předchozích projektů.

\section{Konstrukce}
\label{sec:konstrukce}
Jako nejjednodušší varianta se jevilo využít stavebnici Lego Technics. Z~ní jsme postavili první prototyp. Jednalo se o~jednoduchou kostru s~Ackermanovým podvozkem, na kterou byl připevněn stěžen o~přibližné výšce 40cm s~ráhnem o~délce asi 30cm. Mezi tyto dva díly jsme přišili plachtu ze syntetického pauzovacího papíru, o~kterém jsme se dozvěděli na modelářských fórech jako o~lehce dostupném materiálu pro výrobu plachet. Na tomto modelu jsme ověřili, že je schopen se pohybovat na vítr. Zjistili jsem však, že použitá Legová kolečka mají hrubý vzorek, který vytváří malý odpor, avšak i tento malý odpor už způsoboval problémy při rozjezdu. Při použití jiných, hladších koleček se situace zlepšila, ale odpor v~kolečkách stále nebyl dostatečně malý, aby se plachetnice pohybovala i proti směru větru.

Ukázalo se však, že Lego není úplně vhodným stavebním materiálem. Jednak jsme zjistili, že je obtížné na něj připevnit FITkit a servomotory, druhak není příliš pevné a na pohled se zdálo, že by se silou serv\footnote{Zvlášť jsme měli obavy z~většího serva, které má točivý moment 25\,kg/cm.} mohlo polámat. Také stěžen se náporem větru mírně prohýbal, přičemž jsme do budoucna uvažovali o~ještě větší plachtě. Proto jsme se rozhodli pro stavbu druhého modelu ze stavebnice Merkur.

Stavba z~Merkuru byla podstatně zdlouhavější (i za pomoci aku šroubováku), na druhou stranu však působila mnohem pevnějším dojmem.

Zjistili jsme, že rozteč děr v~dílech Merkuru neodopovídá rozteči úchytů na FITkitu ani serv. Naštěstí jsou v~Merkuru i dílky s~oválnými dírami, díky kterým se nám podařilo uchytit FITkit a větší servo, které ovládá stěžeň. Tím jsme ovšem všechny tyto dílky spotřebovali.

U~ovládání podvozku jsme proto už s~Merkurem nevystačili. Jako ideální materiál se ukázal kuprextit, ze kterého jsme si na míru vyrobili zbylé díly. Použili jsme jej jak k~upevnění servomotoru na kostru, tak k~propojení ovládání podvozku s~hřídelí servomotoru.

Po naprogramování a spuštění řídicího softwaru jsme zjistili, že kvůli setrvačnosti ráhna měl stěžen tendenci se otáčet více než bylo třeba, a proto stále osciloval okolo určené polohy. To se nám podařilo vyřešit pomocí dvou gumiček do vlasů upevněných naproti sobě.

Protože běžná kolečka z~Merkuru jsou bez pneumatik, pomohli jsme si O-kroužkovým těsněním. Zakoupili jsme je přesně na míru, nicméně na špatná kolečka -- dvě z~nich byla natolik pokřivená, že se plachetnice nemohla rozjet. Proto jsme na řídicí nápravu použili jiná, větší a rovnější. K~nim jsme ale neměli O-kroužky. Místo nich nás napadlo použít koaxiální kabel, který jsme obmotali dokola a volné konce spájeli k~sobě. \ref{fig:kolecka}



\section{Senzory}
Robot zpracovává vstupy ze dvou senzorů. První z~nich je jednokanálový inkrementální optický enkodér používaný k~odometrii. Druhý je magnetický enkodér, který měří aktuální směr větru.

\subsection{Optický enkokdér}
Kvůli požadavku na autonomní řízení jsme potřebovali senzor, který by nám umožnil určit relativní pozici plachtenice v~prostoru. Jako vhodný prostředek se jevilo použití odometrie a inkrementálního enkodéru připevněného na hřídel nápravy.

Zprvu jsme chtěli zakoupit komerčně vyráběný enkodér, jehož zapojení by bylo jistě rychlé a jednoduché. Po shlédnutí nabídek několika obchodů jsme ale zjistili, že koupit vhodný a pro naše potřeby přijatelný enkodér, nebude možné. Největší úskalí bylo v~tom, že jsme požadovali takový enkodér, jehož připojení k~nápravě by nijak nezvyšovalo její otáčivý odpor. Většina levných enkodérů však pracovala na principu otáčení potenciometrem, který již z~principu při otáčení odpor produkuje. Ani u~optických nebo magnetických enkodérů jsme neměli jistotu, že s~nimi půjde otáčet dostatečně hladce. Jejich určení bylo totiž k~měření otáček motorů, kterým překonání jejich otáčivého odporu nečiní nejmenší problém. Rozhodli jsme se proto, že enkodér vytvoříme vlastními silami na optickém nereflexivním principu.

Nejdříve jsme měli v~plánu zvýšit rychlost otáček převodovkou s~ozubenými koly z~Merkuru tak, abychom dosáhli přesnosti komerčních enkodérů. Po zdravé úvaze jsme ale dospěli k~závěru, že by se sice jednalo o~efektní řešení, které by ale zbytečně vytvářelo nechtěný odpor. Pro naše jednoduché měření nám totiž stačí jen enkodér s~minimálním rozlišením. Teoreticky by stačilo, když by enkodér dával impulz jednou za otáčku. Protože jsme se ale snažili vždy volit nejjednodušší variantu, připevnili jsme přímo na hřídel nápravy ještě menší kolečko z~Merkuru, které již obsahovalo 6 rovnoměrně rozmístěných děr. Rozlišení našeho enkodéru je tedy ve výsledku jeden impulz za každých $60^\circ$. To při poloměru kolečka 34mm odpovídá jednomu impulzu za každých uražených 35mm. Jak bylo řečeno v~kapitole~\ref{sec:konstrukce} každá z~náprav používá jiný poloměr kol. Toho jsme využili a na měřenou nápravu použili kolečka menšího průměru, která se tak musí rychleji otáčet, což poskytuje lehké zvýšení přesnosti senzoru.

Elektronická část enkodéru se skládá z~fotodiody BPW34 (pracující ve viditelném světelném spektru) a modré supersvítivé LED, která se stará o~její osvit. Dioda je zapojena jako \emph{hradlový článek}, pracuje tedy jako zdroj napětí. Vhodnější by jistě bylo její zapojení jako \emph{spínací diody}, kdy by byla připojena na bázi tranzistoru. Zapojení jako hradlový článek totiž později provázely potíže, které se nám podařilo identifikovat až při jejich vyřešení. Zjistili jsme tak, že zapojení není úplně vhodné, ale protože bylo po korekcích (budou popsané později) funkční, tak jsme hradlové zapojení diody v~enkodéru ponechali.

Aby bylo možné číst výstup senzoru pomocí portu FITkitu, potřebovali jsme zvýšit napětí generované fotodiodou. To je totiž i při silném osvitu přibližně $0.5$V, což je napětí, které běžný port MCU nerozliší od napětí nulového. Nevhodným řešením by jistě bylo použití ADC, proto jsme použili operační zesilovač 4558c, který měl dynamický rozsah generovaných napětí zvyšovat v~intervalu $0-3.3$V. Pro vyhlazení hazardních stavů jsme navíc mezi OZ a MCU zapojili Schmittův klopný obvod HCF40106BE. Popsané schéma zapojení lze nalézt na obrázku~\ref{fig:schema1}.

\begin{figure}[h]
\centering
\includegraphics[width=8.0cm]{img/schema1.ps}
\caption{Předpokládané zapojení optického enkodéru.}
\label{fig:schema1}
\end{figure}

Přestože se zdá toto zapojení korektní, po jeho fyzické realizaci jsme zjistili, že není funkční. Operační zesilovač se choval tak, jakoby na jeho kladný vstup nebyl připojen žádný vodič. Pokud jsme však připojili libovolné jiné napětí, které nebylo generováno fotodiodou, vše fungovalo správně. Po vyzkoušení všech možných i nemožných zapojení jsme zjistili, že obvod se chová správně, pokud jsou namísto jedné fotodiody použity dvě fotodiody v~sériovém zapojení. Předpokládáme, že toto chování je způsobeno tím, že jedna fotodioda není schopna dodat dostatečný proud na to, aby operační zesilovač změnu napětí zaregistroval. Jedná se však pouze o~naši domněnku.

Použít dvě sériově zapojené fotodiody se nezdálo jako vhodné řešení, protože by vznikal problém s~jejich společným osvitem a možná i další problémy. Vhodným řešením se ale ukázalo připojení pevného napětí (cca 0.4V) před fotodiodu. Samotná fotodioda poté dodá zbývající napětí, které je nutné pro překročení prahu operačního zesilovače. Takové zapojení, i když bylo získáno pomocí mnoha pokusů, je funkční a spolehlivé, proto jsme je použili i ve výsledné konstrukci. Schéma konečného zapojení lze nalézt na obrázku~\ref{fig:schema2}.

\begin{figure}[h]
\centering
\includegraphics[width=8.0cm]{img/schema2.ps}
\caption{Funkční zapojení optického enkodéru.}
\label{fig:schema2}
\end{figure}

\subsection{Magnetický enkodér}
Druhým senzorem, který je potřeba pro správnou funkčnost plachetnice je elektronická korouhvička pro určování směru větru. Podle jeho údajů je plachatnice schopna natáčet správně plachtu. Zde jsme se také pokusili získat komerčně vyráběný senzor, zjistili jsme však, že ve velikosti jakou požadujeme, se takovýto senzor koupit nedá.

Nejdříve jsme plánovali vyrobit inkrementální optický senzor podobně jako enkodér pro odometrii s~tím rozdílem, že zde bychom vytvořili klasický tříkanálový inkrementální enkodér. Po problémech s~jednokanálovým enkodérem jsme však od tohoto postupu ustoupili a vypůjčili si magnetický senzor AS5045.

Výroba korouhvičky z~Merkuru byla poměrně jednoduchá. Na její spodní část je oboustrannou lepící páskou přilepen neodymový magnet, který se otáčení spolu s~korouhvičkou. Naproti němu ve vzdálenosti cca 2mm je přilepen zapůjčený senzor. Senzor byl již připájen na DSP s~jednoduchým rozhraním. Stačilo tedy pouze propojit jeho porty s~porty FITkitu.

Čtení dat ze senzoru se odehrává celé v~MCU. Jedná se o~synchronní komunikaci typu master-slave. MCU zahájí komunikaci nastavením hodnoty ENABLE. Dále vysílá hodinový takt a senzor při každé nástupné hraně vystavý jeden bit z~18ti bitového slova, které mimo jiné přímo obsahuje absolutní směr magnetu. Čtení se odehrává přímo v~hlavní smyčce MCU, ve které se při každém průchodu změní hodnota taktovacího signálu. Po dokončení komunikace se přečtená hodnota upraví do vhodného úhlu pro plachty. Požadovaná hodnota se odešle jako příkaz pro servomotor hlavní plachty. Čtení senzoru a případná úprava směru plachty probíhá tímto způsobem přibližně třikrát za sekundu.



\section{Servomotory}
Plachetnice je ovládána pomocí dvou nezávislých servomotorů -- jeden z~nich
otáčí stěžněm, druhý je napojen na podvozek a řídí natočení zadních kol.

Použité servomotory jsou řízeny pulsně šířkovou modulací (\emph{Pulse Width
Modulation}, PWM). Na řídicí vodič jsou posílány pulsy s~periodou $20\,ms$
($50\,Hz$). Šířka pulsu pak určuje natočení hřídele servomotoru a pohybuje se
mezi $600$ a $2\,400\,\mu{}s$. \cite{modelarska_stranka_dohledam_doma}

Samotné generování pulsů je řešeno řadičem implementovaným na FPGA poli na
FITkitu a je nezávislé na práci mikrokontroléru, odpadá tedy starost s~přesným
časováním. Generátor se skládá z~volně běžícího čítače a dvou komparátorů. Tento
celek je implementován jako samostatná komponenta nazvaná \texttt{PWM}. Na její
vstup jsou připojeny dva registry, se kterými je porovnávána hodnota čítače. Po
resetu (spuštění) zařízení je na výstupu generátoru logická 1. Jakmile čítač
dosáhne hodnoty prvního z~registrů, je výstup překlopen na logickou 0. Po
dosažení hodnoty druhého registru se čítač vynuluje, na výstup se nastaví
logická 1 a celý cyklus se opakuje.

Pro komunikaci s~mikrokontrolérem se používá komunikační systém FITkitu,
postavený nad sběrnicí SPI \cite{fitkit_communication}. Implementačně je blok
SPI dekodéru, dvou registrů\footnote{Přesněji se jedná o~blok dvou registrů
s~multiplexovaným vstupem a výstupem a zároveň oddělenými výstupy pro každý
z~registrů; jedná se o~komponentu \texttt{servo\_ctrl\_reg}.} (pro nastavení
střídy a periody) a vytvořené komponenty \texttt{PWM} zapouzdřen do další
komponenty, nazvané \texttt{Servo}. Blokové schéma této komponenty je na obrázku
\ref{fig:fpga_servo}. Generátor PWM je v~této komponentě obsažen dvakrát --
druhý z~nich ovšem pracuje s~64krát delší periodou a střídou a jeho výstup je
možné připojit na LED diodu\footnote{Jedná se o~výstup \texttt{LED} komponenty
\texttt{Servo}.}. Při vývoji se tak dá orientačně kontrolovat, zda vše pracuje
dle očekávání\footnote{Navíc při chybném výstupu (například při trvalé hodnotě 1
nebo 0) se LED nepoškodí, narozdíl od servomotoru, který se může spálit. Toho
jsme několikrát využili při hledání chyb v~implementaci.}.

Řadiči je nutno přidělit adresu v~rámci komunikačního systému, přes kterou mu
jsou zasílány hodnoty periody (pouze při resetu zařízení) a střídy (v~případě
potřeby). Uložené hodnoty lze také číst. Platí, že na určené adrese je
zpřístupněn registr obsahující délku periodu, na adrese zvýšené o~jedničku pak
registr s~délkou střídy. Obě hodnoty vyjadřují počet taktů.

Generátory signálu PWM lze také v~případdě potřeby vypínat. K~tomu slouží vstup
řadiče EN, který je aktivní v~logické 1.

Při použitém taktu FPGA $40\,MHz$ je pro dosažení požadované periody 20\,ms,
neboli 400~tisíc taktů, potřeba alespoň 19bitový čítač, a tedy i 19bitové
regitry pro nastavení hodnot komparátorů. Protože je ale mikrokontrolér FITkitu
pouze 16bitový, snížili jsme počet přenášených bitů na 16. U~periody jsme se
rozhodli snížit přesnost -- pomocí SPI se přenáší horních 16~bitů, dolní tři
bity jsou vždy nastaveny na nulu. Naopak, hodnota střídy je oproti periodě malá
a není třeba využít celý rozsah 19bitových čísel -- přenáší se tedy dolních
16~bitů, horní tři bity jsou vždy nulové.

Pro případné vypnutí servomotoru je v~hlavní komponentě FPGA (viz schéma na
obrázku \ref{fig:fpga_top}) umístěn řídicí 16bitový registr\footnote{Komponenta
\texttt{register}.}. Z~něj jsou využity pouze dva nejvýznamnější bity, každý
z~nich je připojen na vstup EN příslušného řadiče servomotoru. Ostatní bity jsou
v~tuto chvíli bez využití, ale uvažovali jsme například o~řízení osvětlení
plachetnice pro noční \uv{plavby} -- bity 0 až 9 jsou (nejen) pro tento účel
vyvedeny na sběrnici X (konektor \texttt{JP10}). Zápis a čtení hodnot je opět
realizováno pomocí sběrnice SPI\footnote{Komponenta \texttt{register\_spi}.}.

Komponentu řadiče servomotoru využíváme dvakrát -- každá obsluhuje jeden
servomotor. Pro práci na straně mikrokontroléru jsou vytvořeny pomocné funkce
(implementované v~\texttt{servo.h}), které kromě komunikace s~řadičem zajišťují
také přepočet údajů v~mikrosekundách na počet taktů (při taktovací frekvenci
40\,Hz).



\begin{figure}[h]
\label{fig:fpga_servo}
\caption{Schéma řídicího obvodu servomotoru}
\centering
\begin{Verbatim}
  .--- Servo ------------------------------------------------------------------.
  |                                                                            |
  |               .----- SPI_adc -----.       .--- servo_ctrl_reg ---.         |
--|- CLK ---------| CLK       ADDR(0) |-------| MUX        DOUT_FLIP |-----.   |
--|- SPI_CS ------| CS       DATA_OUT |-------| DIN         DOUT_MAX |--.  |   |
--|- SPI_DO ------| DO        DATA_IN |-------| DOUT                 |  |  |   |
--|- SPI_DO_VLD --| DO_VLD   WRITE_EN |-------| WE                   |  |  |   |
--|- SPI_DI ------| DI        READ_EN |--     |                      |  |  |   |
--|- SPI_DI_REQ --| DI_REQ            |    .--| RESET                |  |  |   |
  |               '-------------------'    |  '----------------------'  |  |   |
--|- EN                                    |                            |  |   |
--|- RESET                        RESET <--'                            |  |   |
  |                                                                     |  |   |
  |              .----- PWM (19 bits) -----.                            |  |   |
  |       CLK <--| CLK     MAX_VAL(18..03) |----------------------------o  |   |
  |     RESET <--| RESET   MAX_VAL(02..00) |--"000"                     |  |   |
  |        EN <--| EN                      |                            |  |   |
  |              |        FLIP_VAL(18..16) |--"000"                     |  |   |
--|- SERVO ------| DOUT   FLIP_VAL(15..00) |----------------------------)--o   |
  |              '-------------------------'                            |  |   |
  |                                                                     |  |   |
  |                                                                     |  |   |
  |                                                                     |  |   |
  |              .----- PWM (25 bits) -----.                            |  |   |
  |       CLK <--| CLK     MAX_VAL(24..09) |----------------------------'  |   |
  |     RESET <--| RESET   MAX_VAL(08..00) |--"000000000"                  |   |
  |        EN <--| EN                      |                               |   |
  |              |        FLIP_VAL(24..22) |--"000"                        |   |
  |              |        FLIP_VAL(21..06) |-------------------------------'   |
--|- LED --------| DOUT   FLIP_VAL(05..00) |--"000000"                         |
  |              '-------------------------'                                   |
  |                                                                            |
  '----------------------------------------------------------------------------'
\end{Verbatim}
\end{figure}


\begin{figure}[h]
\label{fig:fpga_top}
\caption{Schéma celkového zapojení na FPGA}
\centering
\begin{Verbatim}
  .--- TOP ---------------------------------------------------.
  |                                                           |
  |                  .---- register_spi ----.                 |
--|- CLK ------------| CLK       DOUT(9..0) |----- X(43..34) -|-- JP10(48..39)
--|- RESET ----------| RESET                |                 |
--|- SPI_CS ---------| SPI_CS               |                 |
--|- SPI_DO ---------| SPI_DO               |                 |
--|- SPI_DO_VLD -----| SPI_DO_VLD           |                 |
--|- SPI_DI ---------| SPI_DI      DOUT(15) |-----o--- X(45) -|-- JP10(50)
--|- SPI_DI_REQ -----| SPI_DI_REQ  DOUT(14) |--o--)--- X(44) -|-- JP10(49)
  |                  '----------------------'  |  |           |
  |                                            |  |           |
  |                                            |  |           |
  |                                            |  |           |
  |                  .-- Servo (wheels) --.    |  |           |
  |           CLK <--| CLK             EN |----'  |           |
  |         RESET <--| RESET              |       |           |
  |        SPI_CS <--| SPI_CS       SERVO |-------)--- X(16) -|-- JP10(21)
  |        SPI_DO <--| SPI_DO         LED |-------)--- X(20) -|-- JP10(25)
  |    SPI_DO_VLD <--| SPI_DO_VLD         |       |           |
  |        SPI_DI <--| SPI_DI             |       |           |
  |    SPI_DI_REQ <--| SPI_DI_REQ         |       |           |
  |                  '--------------------'       |           |
  |                                               |           |
  |                                               |           |
  |                                               |           |
  |                  .--- Servo (mast) ---.       |           |
  |           CLK <--| CLK             EN |-------'           |
  |         RESET <--| RESET              |                   |
  |        SPI_CS <--| SPI_CS       SERVO |----------- X(18) -|-- JP10(23)
  |        SPI_DO <--| SPI_DO         LED |----------- X(21) -|-- JP10(26)
  |    SPI_DO_VLD <--| SPI_DO_VLD         |                   |
  |        SPI_DI <--| SPI_DI             |                   |
  |    SPI_DI_REQ <--| SPI_DI_REQ         |                   |
  |                  '--------------------'                   |
  |                                                           |
  '-----------------------------------------------------------'
\end{Verbatim}
\end{figure}

\section{Řídicí software}
Řízení plachetnice je plně automatické. Na základě údajů získaných z~korouhvičky (tedy magnetického enkodéru) se upravuje střída PWM signálu servomotoru, který ovládá stěžen. Pro vztah mezi směrem větru a natočením plachet byla použita jednoduchá jachtařská pomůcka, která říká, že úhel plachty by měl dělit úhel mezi směrem lodi a směrem větru právě na poloviny.

Plachetnici lze v~hlavní smyčce naprogramovat schéma, podle kterého má po spušení natáčet kola podvozku. Lze zde nastavit úhel natočení kol v~závislosti na aktuální ujeté vzdálenosti. To umožňuje nastavit plachetnici, aby jezdila před větráky například dokolečka nebo do osmičky. Tento způsob řízení má však dvě úskalí. Zaprvé je velmi nepřesné a plachetnice není schopná opsat přesné kolečko. Zadruhé vyžaduje velký rovný prostor, na kterém je silný vítr. Takovéto prostředí se nám však nepodařilo odsimulovat, protože jsme pro testy měli jen omezený počet větráků.

Do řízení je možné zasahovat i ručně pomocí textového terminálu. Jednotlivými příkazy lze nastavovat úhel natočení obou serv, lze je zapínat nebo vypínat a také existují příkazy pro přímý přístup do dolních 9 bitů řídicího registru. Kompletní seznam příkazů se zobrazí příkazem \texttt{HELP}, zde jej neuvádíme.

\section{Závěr}
Podařilo se nám vytvořit model plachetnice, která se umí za vhodných podmínek (rovná podlaha a silný vítr) autonomně pohybovat po nastavené trase ve větru. Informace o~prostředí získává ze dvou senzorů. Z~prvního získává údaj o~aktuálním směru větru a z~druhého si dopočítává svoji relativní pozici v~prostoru.

Ruční řízení pomocí textových příkazů zasílaných terminálem není příliš uživatelsky příjemné. Vhodným rozšířením by tak bylo grafické uživatelské rozhraní pracující nad terminálem, které by přehledně zobrazovalo natočení plachty a koleček a údaje načítané ze senzorů, například směr větru, rychlost pohybu vůči zemi nebo ujetou vzdálenost. Také by umožňovalo intuitivní ovládání jednotlivých komponent bez nutnosti zkoumat, co jednotlivé příkazy znamenají.

Uvažovali jsme také o~bezdrátovém řízení pomocí komunikačních modulů dostupných k~FITkitu (v~pásmu 2,4\,GHz)\footnote{Viz \url{http://merlin.fit.vutbr.cz/FITkit/hardware.html}}. Ty jsou ovšem navrženy primárně pro FITkit verze 2, které se nám, přes veškerou naši snahu, získat nepodařilo. Bylo by možné je použít i s~FITkitem verze 1.2, se kterými jsme pracovali, ale pouze pokud bychom si vytvořili vlastní řídicí software\footnote{Hlavním důvodem je, že MCU na FITkitu 1.2 nepodporuje na jednom portu provozovat jak UART (pro komunikaci s~terminálem) tak SPI (pro komunikaci s~bezdrátovým modulem).}.

\subsection{Rozdělení práce}

Celkově pro nás není lehké rozdělit projekt na části, u~kterých bychom jednoznačně určili autora. Následující přehled tedy spíše zahrnuje oblasti, ve kterých účast jednoho z~nás výrazně převažovala.

\begin{itemize}
  \item Aleš Horký -- konstrukce, senzory (konstrukce i komunikace), pájka\footnote{Včetně oprav odpadnutých špatně spájených drátků.}
  \item Michal Wiglasz -- konstrukce, ovládání servomotorů (FPGA i MCU)
\end{itemize}

%bibliografie
\newpage
\bibliographystyle{czechisoutf}
\bibliography{dokumentace}

\end{document}
